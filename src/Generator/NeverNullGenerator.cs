using System;
using System.Linq;
using System.Threading;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using NeverNull.Generator.Extensions;

namespace NeverNull.Generator
{
    /// <summary>
    /// An <see cref="IIncrementalGenerator"/> source generator for the <c>[NeverNull]</c> attribute.
    /// </summary>
    [Generator]
    public sealed class NeverNullGenerator : IIncrementalGenerator
    {
        public void Initialize(IncrementalGeneratorInitializationContext context)
        {
            // define a pipeline to find all [NeverNull] fields
            var neverNulls = context.SyntaxProvider
                .CreateSyntaxProvider(IsMemberSyntax, TransformMember)
                .Where(x => x.Symbol.HasNeverNullAttribute());

            // register the source output for compilation
            context.RegisterSourceOutput(neverNulls, GenerateNeverNullSource);
        }

        private void GenerateNeverNullSource(SourceProductionContext sourceContext, (MemberDeclarationSyntax MemberDeclaration, ISymbol? Symbol) member)
        {
            // filter out anything that is not a field or a value type
            var memberSymbol = member.Symbol;
            if (memberSymbol == null ||  memberSymbol is not IFieldSymbol typeSymbol || typeSymbol.Type.TypeSymbolIsValueType())
            {
                return;
            }

            // determine member type name
            string typeName = memberSymbol switch
            {
                IFieldSymbol fs => fs.Type.ToDisplayString(),
                _ => string.Empty
            };

            // determine how to initialize the member
            string initializerText = GetInitializerText(member.MemberDeclaration, typeName);
            if (string.IsNullOrEmpty(initializerText))
            {
                return;
            }

            // enforce non-nullability and immutability for fields and properties
            var generatedSource = GenerateNeverNullCode(memberSymbol, typeName, memberSymbol.Name, initializerText);

            // generate source file
            sourceContext.AddSource($"{memberSymbol.ContainingType.Name}_{memberSymbol.Name}.NeverNull.g.cs", generatedSource);
        }

        private string GetInitializerText(MemberDeclarationSyntax member, string typeName) => member switch
        {
            FieldDeclarationSyntax f => f.Declaration.Variables.FirstOrDefault()?.Initializer?.Value.ToFullString()
                ?? (typeName.Equals("string", StringComparison.OrdinalIgnoreCase) ? "string.Empty" : $"new {typeName}()"),
            _ => string.Empty
        };

        private string GenerateNeverNullCode(ISymbol memberSymbol, string typeName, string memberName, string initializerText)
        {
            var @namespace = memberSymbol.ContainingNamespace.IsGlobalNamespace ? "" : $"namespace {memberSymbol.ContainingNamespace.ToDisplayString()};";
            var className = memberSymbol.ContainingType.Name;

            var privateAccessor = memberSymbol.IsStatic ? "private static" : "private";
            var publicAccessor = memberSymbol.IsStatic ? "public static" : "public";
            var initializationAccessor = memberSymbol.IsStatic ? "static" : "public";
            var privateFieldName = $"_NeverNull_{memberName}";
            var publicPropertyName = $"NeverNull_{memberName}";

            return $$"""
// <auto-generated/>
{{@namespace}}

public partial class {{className}}
{
    {{privateAccessor}} {{typeName}} {{privateFieldName}};

    {{publicAccessor}} {{typeName}} {{publicPropertyName}}
    {
        get => {{privateFieldName}} ?? ({{privateFieldName}} = {{initializerText}});
        set => {{privateFieldName}} = value ?? {{initializerText}};
    }

    {{initializationAccessor}} {{className}}()
    {
        {{memberName}} = {{publicPropertyName}};
    }
}
""";
        }

        private static bool IsMemberSyntax(SyntaxNode syntaxNode, CancellationToken _cancellationToken)
            => syntaxNode is FieldDeclarationSyntax f && f.AttributeLists.Count > 0;

        private (MemberDeclarationSyntax MemberDeclaration, ISymbol? Symbol) TransformMember(GeneratorSyntaxContext context, CancellationToken _cancellationToken)
            => context.Node is FieldDeclarationSyntax field
                ? (field, context.SemanticModel.GetDeclaredSymbol(field.Declaration.Variables.First()))
                : ((MemberDeclarationSyntax)context.Node, null);
    }
}